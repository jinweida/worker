# 秒杀系统的特点
1、大量请求同时发起（高并发），服务器必须尽快处理每个请求，才能保证秒杀请求不超时

2、秒杀商品不能发生超卖，为了不超卖，必须有一个统一处理的地方排队减少库存。

3、秒杀开始一段时间，服务器请求压力突增会影响正常售卖，解决高并发，可以增加服务器进行负载分担，但减少库存是单点操作，请求都会卡在数据库减少库存上，导致所有请求处理变慢

# 解决方案

1、解决高并发请求问题

通过反向代理进行负载分担，增加后端服务器数量

2、解决数据库减库存阻塞请求问题

使用消息队列（MQ）队列，把秒杀请求先放入队列，后端服务在慢慢处理队列的秒杀消息，把请求成功的存入数据库被查。

使用MQ队列秒杀请求变成了异步处理，需要客户端在发送秒杀请求后，再次延迟发送结果查询请求，查询到秒杀成功用户在进入购买流程。

3、解决秒杀冲击正常售卖，把秒杀请求和正常售卖做物理隔离

![image](https://camo.githubusercontent.com/9e99c7b72a62b8690006f167b2bd793bf9cbcd45/687474703a2f2f6f67307379626e69782e626b742e636c6f7564646e2e636f6d2f5672555a4e726a253230253238312532392e6a7067)

# 秒杀方案优化

1、在高并发处理过程中，尤其要注意锁的应用，尽量避免锁等待导致的线程切换。根据应用的场景，可以选择原子变量 ( 如计数器 ) ，读写锁，细粒度锁；

2、需要集中式验证的处理，比如验证当前库存是否大于零，可以通过本地缓存 的库存进行验伪；

3、应用本地缓存减少对外部系统 ( 数据库等 ) 的重复调用，比如 对 用户 token 合法性的验证，可以在秒杀开始之前通过 Ajax 发送预热请求，提前缓存好用 户 token 的验证结果，结合到负载分担服务器的会话保持，可以很大提高本地缓存的命中率。
