#### 3.1 概述
- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

#### 3.2 如何判断对象已死？
- 引用计数算法

    主流java虚拟机没有采用这个算法管理内存，它很难解决对象之间相互循环引用的问题
- 可达性分析算法

#### 3.3 垃圾收集算法
- 标记-清除算法
- 复制算法
- 标记-整理算法
- 分代收集算法

#### 3.4 HotSpot的算法实现
- 枚举根节点
- 安全点
- 安全区域

#### 3.5 垃圾收集器
- Serial 收集器
- ParNew收集器
- Parallel Scavenge收集器
- Serial Old 收集器
- Parallel Old收集器
- CMS收集器
- G1收集器

#### 3.6 内存分配与回收策略

对象内存分配，往大方向讲就是在堆上分配（也可能经过jit编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况也可能分配在老年代中。

- 对象优先在Eden分配

    在大多数情况下，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
    
    -Xms20M、-Xmx20M、-Xmn10M 三个参数设置了java堆大小为20M，不可扩展，其中10M
    分给新生代，10M分给老年代
    
    -XX:SurvivorRatio=8 决定了新生代中Eden区与Survivor区 空间比例为8:1

- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
- 空间分配担保
- 