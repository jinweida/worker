#### 3.1 概述
- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

#### 3.2 如何判断对象已死？
- 引用计数算法

    主流java虚拟机没有采用这个算法管理内存，它很难解决对象之间相互循环引用的问题
- 可达性分析算法

#### 3.3 垃圾收集算法
- 标记-清除算法
- 复制算法
- 标记-整理算法
- 分代收集算法

#### 3.4 HotSpot的算法实现
- 枚举根节点
- 安全点
- 安全区域

#### 3.5 垃圾收集器
- Serial 收集器
- ParNew收集器
- Parallel Scavenge收集器
- Serial Old 收集器
- Parallel Old收集器
- CMS收集器
- G1收集器

#### 3.6 内存分配与回收策略

对象内存分配，往大方向讲就是在堆上分配（也可能经过jit编译后被拆散为标量类型并间接在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况也可能分配在老年代中。

- 对象优先在Eden分配

    在大多数情况下，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
    
    -Xms20M、-Xmx20M、-Xmn10M 三个参数设置了java堆大小为20M，不可扩展，其中10M
    分给新生代，10M分给老年代
    
    -XX:SurvivorRatio=8 决定了新生代中Eden区与Survivor区 空间比例为8:1

- 大对象直接进入老年代
    
    - 虚拟机提供了-XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接进入咯啊年代分配，目的是避免在Eden区及两个Survivor区之间发生大量的内存复制
    - 此参数只对Serial和ParNew两款收集器有效。Parallel Scavenge收集器不认识这个参数
- 长期存活的对象将进入老年代    

    虚拟机给每个对象定一个对象年龄（age）计数器，如果对象在Eden区出生并经过第一次Minor GC后仍然存在，并能被Survivor容纳，将被移动到Survivor空间中，并且年龄设为1，对象在Survivor区 每熬过一次Minor GC 年龄就增加1岁，当年龄增加到一定程度（默认15岁），就被晋升到老念中，这个晋升老年的年龄阀值，可以通过参数-XX:MaxTenuringThreshold设置
- 动态对象年龄判定

    虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄所有对象大小的总和大雨Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄
- 空间分配担保