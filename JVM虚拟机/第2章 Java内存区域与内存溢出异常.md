#  运行时数据区域
![image](https://raw.githubusercontent.com/jinweida/worker/master/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/145540ib3ztwzt8rj13ow1.png.thumb.jpg)
#### 1.程序计数器

- 是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器

- 如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址

- 如果正在执行的是Native方法，这个计数器值则为空（undefined），此区域是唯一没有OutOfMemoryError情况的区域
- 线程私有的
    
#### 2.虚拟机栈

- 线程私有的
- 描述的是Java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态连接方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程
- 局部变量表存放了编译期的各种数据类型（boolean，byte，char，short，int，float，long，double），对象引用（reference）类型（指针或者句柄）
- 此区域 出现异常

    - 如果线程请求的栈深度大雨虚拟机所允许的深度，将抛出StackOverflowError异常
    - 如果虚拟机栈可以动态扩展，如果扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常
    
#### 3.本地方法栈
- 与虚拟机栈类似
- 为虚拟机使用到得Native方法服务
- 也会抛出StackOverflowError和OutOfMemoryError错误

#### 4.Java堆
- 虚拟机管理得内存中最大一块
- 被所有线程共享得，在虚拟机启启动时创建，此内存区域唯一目的是存放对象实例和数组，几乎所有对象实例和数组都在这里分配内存
- 随着JIT编译器得发展与逃逸分析技术成熟起来，对象得分配在堆上变得不那么绝对了
- Java堆是蓝记收集器管理得主要区域
- 现在垃圾收集器采用分代收集算法，java堆可分为新生代和老年代
- java 堆可划分出多个线程私有得分配缓冲区（Thread Local Allocation Buffer,TLAB）
- 如果在堆中没有内存完成实例分配，并且堆也无法扩展，将会抛出OutOfMemoryError异常

#### 5.方法区
- 与堆一样也是各个线程共享的内存区域
- 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后得代码等数据
- 很多人更愿意把此区域成为“永久代”，本质上两者并不等价
- 虚拟机规范对方法区管理非常宽松，可以选择补实现垃圾收集或者垃圾收集行为在这个区域比较少出现
- 这个区域内存回收目标主要是针对常量池的回收和对类型得卸载
- 当方法区无法满足内存分配时，将会抛出OutOfMemoryError异常


- ==运行时常量池==
    - 是方法区得一部分
    - class文件除了有类得版本，字段，方法，接口等描述信息外，还有一项信息是常量池
    - 用于存放编译期生成得各种字面量和符号引用
    - 具备动态性，运行期间也可能将新的常量放入池中，如：String 类的intern()方法
    - 也会抛出OutOfMemoryError异常
    
#### 6.直接内存
- 不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域
- 也会抛出OutOfMemoryError异常
- jdk1.4新加入了nio（New input/output），引入一种通道（channel）与缓冲（Buffer）方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在堆中的DirectByteBuffer对象作为这块内存的引用操作，避免了java堆与native堆中来回复制数据，提高了性能
- 受本机内存限制，也会抛出OutOfMemoryError异常

